<!-- Need to sort formatting
http://screentime.parsnip.io/
https://firebase.google.com/docs/web/setup?authuser=0 -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.10.2/jquery.js" integrity="sha256-it5nQKHTz+34HijZJQkpNBIHsjpV8b6QzMJs9tmOBSo=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.js" integrity="sha256-epniwOZCSYGoGeC9Db9iF5ZNe1GGtWkJOx9QsjgGG1s=" crossorigin="anonymous"></script>

<script>
/*!
 * @preserve
 * Screentime.js | v0.2.0
 * Copyright (c) 2016 Rob Flaherty (@robflaherty)
 * Licensed under the MIT and GPL licenses.
 */

/* Universal module definition */

(function(factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define(['jquery'], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory(require('jquery'));
  } else {
    // Browser globals
    factory(jQuery);
  }
}(function($) {

  /* Screentime */

  var defaults = {
    fields: [],
    percentOnScreen: '50%',
    reportInterval: 1,
    googleAnalytics: false,
    callback: function(){
	  console.log("default callback called")
	}
  };

  $.screentime = function(options) {
    options = $.extend({}, defaults, options);
	
	console.log(options)
	console.log("setup")

    // Convert perecent string to number
    options.percentOnScreen = parseInt(options.percentOnScreen.replace('%', ''), 10);

    var counter = {};
    var cache = {};
    var log = {};
    var looker = null;
    var started = false;
    var universalGA, classicGA;

    if (!options.fields.length) {
      return;
    }

    if (options.googleAnalytics) {

      if (typeof ga === "function") {
        universalGA = true;
      }

      if (typeof _gaq !== "undefined" && typeof _gaq.push === "function") {
        classicGA = true;
      }

    }

    /*
     * Utilities
     */

    /*!
     * visibly - v0.6 Aug 2011 - Page Visibility API Polyfill
     * http://github.com/addyosmani
     * Copyright (c) 2011 Addy Osmani
     * Dual licensed under the MIT and GPL licenses.
     *
     * Methods supported:
     * visibly.onVisible(callback)
     * visibly.onHidden(callback)
     * visibly.hidden()
     * visibly.visibilityState()
     * visibly.visibilitychange(callback(state));
     */

    (function(){window.visibly={q:document,p:undefined,prefixes:["webkit","ms","o","moz","khtml"],props:["VisibilityState","visibilitychange","Hidden"],m:["focus","blur"],visibleCallbacks:[],hiddenCallbacks:[],genericCallbacks:[],_callbacks:[],cachedPrefix:"",fn:null,onVisible:function(i){if(typeof i=="function"){this.visibleCallbacks.push(i)}},onHidden:function(i){if(typeof i=="function"){this.hiddenCallbacks.push(i)}},getPrefix:function(){if(!this.cachedPrefix){for(var i=0;b=this.prefixes[i++];){if(b+this.props[2]in this.q){this.cachedPrefix=b;return this.cachedPrefix}}}},visibilityState:function(){return this._getProp(0)},hidden:function(){return this._getProp(2)},visibilitychange:function(i){if(typeof i=="function"){this.genericCallbacks.push(i)}var t=this.genericCallbacks.length;if(t){if(this.cachedPrefix){while(t--){this.genericCallbacks[t].call(this,this.visibilityState())}}else{while(t--){this.genericCallbacks[t].call(this,arguments[0])}}}},isSupported:function(i){return this.cachedPrefix+this.props[2]in this.q},_getProp:function(i){return this.q[this.cachedPrefix+this.props[i]]},_execute:function(i){if(i){this._callbacks=i==1?this.visibleCallbacks:this.hiddenCallbacks;var t=this._callbacks.length;while(t--){this._callbacks[t]()}}},_visible:function(){window.visibly._execute(1);window.visibly.visibilitychange.call(window.visibly,"visible")},_hidden:function(){window.visibly._execute(2);window.visibly.visibilitychange.call(window.visibly,"hidden")},_nativeSwitch:function(){this[this._getProp(2)?"_hidden":"_visible"]()},_listen:function(){try{if(!this.isSupported()){if(this.q.addEventListener){window.addEventListener(this.m[0],this._visible,1);window.addEventListener(this.m[1],this._hidden,1)}else{if(this.q.attachEvent){this.q.attachEvent("onfocusin",this._visible);this.q.attachEvent("onfocusout",this._hidden)}}}else{this.q.addEventListener(this.cachedPrefix+this.props[1],function(){window.visibly._nativeSwitch.apply(window.visibly,arguments)},1)}}catch(i){}},init:function(){this.getPrefix();this._listen()}};this.visibly.init()})();

    function random() {
      return Math.round(Math.random() * 2147483647);
    }

    /*
     * Constructors
     */

    function Field(elem) {
      this.selector = elem.selector;
      $elem = this.$elem = $(elem.selector);
      this.name = elem.name;

      this.top = $elem.offset().top;
      this.height = $elem.height();
      this.bottom = this.top + this.height;
      this.width = $elem.width();
    }

    function Viewport() {
      var $window = $(window);

      this.top = $window.scrollTop();
      this.height = $window.height();
      this.bottom = this.top + this.height;
      this.width = $window.width();
    }

    /*
     * Do Stuff
     */

    function sendGAEvent(field, time) {

      if (universalGA) {
        ga('send', 'event', 'Screentime', 'Time on Screen', field, parseInt(time, 10), {'nonInteraction': true});
      }

      if (classicGA) {
        _gaq.push(['_trackEvent', 'Screentime', 'Time on Screen', field, parseInt(time, 10), true]);
      }

    }

    function onScreen(viewport, field) {
      var cond, buffered, partialView;

      // Field entirely within viewport
      if ((field.bottom <= viewport.bottom) && (field.top >= viewport.top)) {
        return true;
      }

       // Field bigger than viewport
      if (field.height > viewport.height) {

        cond = (viewport.bottom - field.top) > (viewport.height / 2) && (field.bottom - viewport.top) > (viewport.height / 2);

        if (cond) {
          return true;
        }

      }

      // Partially in view
      buffered = (field.height * (options.percentOnScreen/100));
      partialView = ((viewport.bottom - buffered) >= field.top && (field.bottom - buffered) > viewport.top);

      return partialView;

    }

    function checkViewport() {
      var viewport = new Viewport();
	  

      $.each(cache, function(key, val) {
        if (onScreen(viewport, val)) {
          log[key] += 1;
          counter[key] += 1;
        }
      });

    }

    function report() {

      var data = {};

      $.each(counter, function(key, val) {
        if (val > 0) {
          data[key] = val;
          counter[key] = 0;

          if (options.googleAnalytics) {
            sendGAEvent(key, val);
          }

        }
      });

      if (!$.isEmptyObject(data)) {
        options.callback.call(this, data, log);
      }

    }

    function startTimers() {

      if (!started) {
        checkViewport();
        started = true;
      }

      looker = setInterval(function() {
        checkViewport();
      }, 1000);

      reporter = setInterval(function() {
        report();
      }, options.reportInterval * 1000);

    }

    function stopTimers() {
      clearInterval(looker);
      clearInterval(reporter);
    }

    $.screentime.reset = function() {
      stopTimers();

      $.each(cache, function(key, val) {
        log[key] = 0;
        counter[key] = 0;
      });

      startTimers();
    }

    function init() {

      $.each(options.fields, function(index, elem) {
        if ($(elem.selector).length) {
          var field = new Field(elem);
          cache[field.name] = field;
          counter[field.name] = 0;
          log[field.name] = 0;
        }
      });

      startTimers();

      visibly.onHidden(function() {
        stopTimers();
      });

      visibly.onVisible(function() {
        stopTimers();
        startTimers();
      });

    }

    init();

  };

}));
</script>

<!-- <script type="text/javascript" src="https://raw.githubusercontent.com/robflaherty/screentime/master/screentime.js"></script> -->



<div id="console">
    <ul>
      <li data-time="0" data-field="Top">Intro: <span>0</span>s</li>
      <li data-time="0" data-field="Middle">Main: <span>0</span>s</li>
      <li data-time="0" data-field="Bottom">Bottom: <span>0</span>s</li>
    </ul>
</div>

<div id="content">  
<div id="top">

<span style="font-weight:400;">SpatialOS is a managed cloud service to host any synchronous multiplayer game. It is specifically designed to operate online games with new gameplay and enable developers to iterate quickly to find new gameplay that is fun.</p>
</div>

<div id="middle">
<span style="font-weight:400;">The essential and core service SpatialOS provides is server hosting, and facilitating the connection of players to the game so they can play it. This is a globally hosted scalable infrastructure with regions close to all major game playing populations, enabling low latency gameplay for players of SpatialOS games. This is fully managed by Improbable so that the developer no longer needs to worry about server management. Because of this, it is easier for teams of all sizes to create online games. SpatialOS can be hosted on all major public cloud providers.</p>

<span style="font-weight:400;">The SpatialOS Runtime is the foundational system for the service -- it makes it possible for these games to exceed the limitations of a single game engine or server, by distributing the game logic and game data across multiple servers. This enables larger seamless worlds with more complex game objects, more detailed/complex AI, additional gameplay systems and higher fidelity gameplay at scale. It also provides an in-memory database that allows all objects in the world to be fully persistent. Finally it replaces a game engines networking and interest management system to allow for more players and denser gameplay scenarios, although it does not replace the game logic. These elements can be mixed arbitrarily without tradeoffs.</p>

<span style="font-weight:400;">SpatialOS also has features that enable developers to explore new gameplay quickly. To do this we provide three major elements:</p>
<ul>
	<li style="font-weight:400;"><span style="font-weight:400;">Out of the box tooling: Tooling that comes with SpatialOS to help developers understand what is happening in their game world. These include a distributed metrics service, logging service)</span></li>
	<li style="font-weight:400;"><span style="font-weight:400;">Service to efficiently test your game: An automated player testing service and a light-weight distribution service and the ability to deploy globally rapidly (including to China).</span></li>
	<li style="font-weight:400;"><span style="font-weight:400;">A set of services which developers can extend to integrate/create their own workflows (i.e build systems) and integrate their own 3rd party services (e.g matchmaking, player auth etc).</span></li>
</ul>
</div>

<div id="bottom">
<span style="font-weight:400;">Users write the logic for their game using a game engine, or in C, C++, C# or Java languages, and must integrate these applications with SpatialOS using the SpatialOS SDK. Developers also use the SDK to adapt their workflows and integrate other 3rd party services. The SDKs support all major platforms (PC,Xbox, Playstation, Mobile), and players on these different platforms can interact in the same game world. For the most part this allows users to develop games in the way they are familiar, however they will need to adhere to the SpatialOS programming paradigm and learn some basic distributed systems knowledge. We also provide first party native integrations for Unity and Unreal.</span><code></code>
</div>
</div>

<script>
$.screentime({
  fields: [
    { selector: '#top',
      name: 'Top'
    },
    { selector: '#middle',
      name: 'Middle'
    },
    { selector: '#bottom',
      name: 'Bottom'
    }
  ],
  reportInterval: 1,
  callback: function(data) {
    $.each(data, function(key, val) {
    var $elem = $('#console li[data-field="' + key + '"]');
      var current = parseInt($elem.data('time'), 10);

      $elem.data('time', current + val);
      $elem.find('span').html(current += val);
    });
	console.log(data);
  }
});
</script>